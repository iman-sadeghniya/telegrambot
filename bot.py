import sqlite3 from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup from telegram.ext import Updater, CommandHandler, CallbackQueryHandler, MessageHandler, Filters, ConversationHandler from telegram.ext import CallbackContext import logging # تنظیمات پایه TOKEN = 'YOUR_BOT_TOKEN' DB_NAME = 'shop_database.db' logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO) logger = logging.getLogger(__name__) # مراحل مکالمه ADDRESS, CONFIRM_ORDER = range(2) # راه‌اندازی دیتابیس def init_db(): conn = sqlite3.connect(DB_NAME) c = conn.cursor() c.execute('''CREATE TABLE IF NOT EXISTS products (id INTEGER PRIMARY KEY, name TEXT, price INTEGER)''') c.execute('''CREATE TABLE IF NOT EXISTS cart (user_id INTEGER, product_id INTEGER, quantity INTEGER)''') c.execute('''CREATE TABLE IF NOT EXISTS orders (id INTEGER PRIMARY KEY, user_id INTEGER, total_price INTEGER, status TEXT)''') c.execute('''CREATE TABLE IF NOT EXISTS saved_addresses (user_id INTEGER PRIMARY KEY, address TEXT)''') c.execute('''CREATE TABLE IF NOT EXISTS discounts (code TEXT PRIMARY KEY, percent INTEGER)''') c.execute('''CREATE TABLE IF NOT EXISTS referrals (inviter_id INTEGER, invitee_id INTEGER UNIQUE)''') c.execute('''CREATE TABLE IF NOT EXISTS loyalty_points (user_id INTEGER, points INTEGER)''') conn.commit() conn.close() # شروع فرآیند سفارش def checkout(update: Update, context: CallbackContext): user_id = update.effective_user.id conn = sqlite3.connect(DB_NAME) c = conn.cursor() c.execute('''SELECT products.id, products.name, products.price, cart.quantity FROM cart JOIN products ON cart.product_id = products.id WHERE cart.user_id = ?''', (user_id,)) items = c.fetchall() if not items: update.message.reply_text("سبد خرید شما خالی است.") conn.close() return ConversationHandler.END context.user_data['cart_items'] = items total = sum(p * q for _, _, p, q in items) c.execute("SELECT fee FROM delivery_fee WHERE id = 1") delivery = c.fetchone()[0] context.user_data['total'] = total context.user_data['delivery'] = delivery context.user_data['total_price'] = total + delivery c.execute("SELECT address FROM saved_addresses WHERE user_id = ?", (user_id,)) saved = c.fetchone() conn.close() if saved: keyboard = [ [InlineKeyboardButton("استفاده از آدرس ذخیره شده", callback_data="use_saved")], [InlineKeyboardButton("آدرس جدید", callback_data="new_address")] ] update.message.reply_text("آدرس قبلی شما یافت شد، لطفاً انتخاب کنید:", reply_markup=InlineKeyboardMarkup(keyboard)) return ADDRESS else: update.message.reply_text("آدرس خود را وارد کنید:") return ADDRESS # وارد کردن آدرس def address_step(update: Update, context: CallbackContext): query = update.callback_query if query.data == "use_saved": user_id = query.from_user.id conn = sqlite3.connect(DB_NAME) c = conn.cursor() c.execute("SELECT address FROM saved_addresses WHERE user_id = ?", (user_id,)) context.user_data['address'] = c.fetchone()[0] conn.close() return ask_payment_method(query, context) elif query.data == "new_address": query.edit_message_text("لطفاً آدرس جدید خود را وارد کنید:") return CONFIRM_ORDER return ConversationHandler.END # ذخیره آدرس جدید def save_address(update: Update, context: CallbackContext): address = update.message.text.strip() user_id = update.effective_user.id conn = sqlite3.connect(DB_NAME) c = conn.cursor() c.execute("REPLACE INTO saved_addresses (user_id, address) VALUES (?, ?)", (user_id, address)) conn.commit() conn.close() context.user_data['address'] = address return ask_payment_method(update, context) # انتخاب روش پرداخت def ask_payment_method(update, context): if isinstance(update, Update): send = update.message.reply_text else: send = update.edit_message_text buttons = [ [InlineKeyboardButton("پرداخت آنلاین", callback_data="pay_online")],
[InlineKeyboardButton("پرداخت در محل", callback_data="pay_cod")] ] send("روش پرداخت را انتخاب کنید:", reply_markup=InlineKeyboardMarkup(buttons)) return CONFIRM_ORDER # ثبت سفارش و ارسال به کاربر def confirm_order(update: Update, context: CallbackContext): user_id = update.effective_user.id total_price = context.user_data['total_price'] address = context.user_data['address'] conn = sqlite3.connect(DB_NAME) c = conn.cursor() c.execute('''INSERT INTO orders (user_id, total_price, status) VALUES (?, ?, ?)''', (user_id, total_price, 'در حال پردازش')) conn.commit() update.message.reply_text(f"سفارش شما ثبت شد. آدرس: {address}\nمبلغ کل: {total_price} تومان\nوضعیت: در حال پردازش") # ارسال پیام به ادمین notify_admin_about_new_order(f"سفارش جدید از کاربر {user_id} - مبلغ: {total_price} تومان") conn.close() return ConversationHandler.END # اطلاع رسانی به مدیر پس از ثبت سفارش def notify_admin_about_new_order(order_details): admin_ids = ['ADMIN_USER_ID'] # لیست آیدی‌های ادمین for admin_id in admin_ids: context.bot.send_message(admin_id, order_details) # جستجو و فیلتر محصولات def search_product(update: Update, context: CallbackContext): query = update.message.text.lower() conn = sqlite3.connect(DB_NAME) c = conn.cursor() c.execute("SELECT * FROM products WHERE LOWER(name) LIKE ?", ('%' + query + '%',)) products = c.fetchall() conn.close() if products: for product in products: update.message.reply_text(f"محصول: {product[1]} - قیمت: {product[2]} تومان") else: update.message.reply_text("محصولی پیدا نشد.") # نمایش تاریخچه سفارشات def order_history(update: Update, context: CallbackContext): user_id = update.effective_user.id conn = sqlite3.connect(DB_NAME) c = conn.cursor() c.execute("SELECT * FROM orders WHERE user_id = ?", (user_id,)) orders = c.fetchall() conn.close() if orders: for order in orders: update.message.reply_text(f"سفارش شماره {order[0]}: {order[4]} - مبلغ: {order[2]} تومان") else: update.message.reply_text("هیچ سفارشی ثبت نکردید.") # راه‌اندازی ربات def main(): init_db() updater = Updater(TOKEN) dp = updater.dispatcher # هندلرهای دستورات dp.add_handler(CommandHandler("checkout", checkout)) dp.add_handler(CommandHandler("order_history", order_history)) dp.add_handler(MessageHandler(Filters.text & ~Filters.command, search_product)) # هندلرهای مکالمه conv_handler = ConversationHandler( entry_points=[CommandHandler("checkout", checkout)], states={ ADDRESS: [CallbackQueryHandler(address_step)], CONFIRM_ORDER: [MessageHandler(Filters.text & ~Filters.command, save_address), CallbackQueryHandler(confirm_order)] }, fallbacks=[] ) dp.add_handler(conv_handler) updater.start_polling() updater.idle() if name == '__main__': main() 